{
  "title": "TypesScript Handbook Mark",
  "date": "2022-11-04T02:30:00.000Z",
  "body": {
    "raw": "\n# TypesScript Handbook\n> Much of the time, you will know better than TypeScript.\n\n## å¸¸è§ç±»å‹\n### ç±»å‹åˆ«åå’Œæ¥å£çš„åŒºåˆ« [ğŸ”—](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces)\n- æ‰©å±•\n```typescript\n// interface\ninterfaces A extends B{\n  property1: string;\n  property2: string;\n}\n\n// type alias\ntype A  = {\n  property1: string;\n}\ntype B = {\n  property2: string;\n}\ntype Union = A & B\n```\n- é‡å¤å®šä¹‰ï¼šinterfaceé‡å¤å®šä¹‰æ˜¯å¾€æ¥å£å†…æ·»åŠ å±æ€§ï¼Œtypeç±»å‹åˆ«åä¸èƒ½é‡å¤å®šä¹‰\n\n## Narrowing\n### Truthiness narrowing [ğŸ”—](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#truthiness-narrowing)\n- Double-Boolean negationï¼šTypeScript infers a narrow literal boolean type trueï¼Œrather than boolean.  \n`!!\"str\"; //type: true value: true`  \n`Boolean(\"str); //type: boolean value: true`\n\n## Function Types\n\n## Object Types\n### åªè¯»å±æ€§ï¼š\n- TSåœ¨åˆ¤æ–­æ˜¯å¦æ˜¯åŒä¸€ç±»å‹æ—¶ä¸è€ƒè™‘readonlyå±æ€§\n- å¯é€šè¿‡ä½¿ç”¨åˆ«åæ”¹å˜readonlyå±æ€§\n- æ™®é€šç±»å‹å€¼å¯ä»¥èµ‹å€¼ç»™readonlyå˜é‡ï¼Œä½†readonlyå€¼ä¸èƒ½å¤åˆ¶ç»™æ™®é€šç±»å‹å˜é‡\n```typescript\ninterface Person {\n  name: string;\n  age: number;\n}\n \ninterface ReadonlyPerson {\n  readonly name: string;\n  readonly age: number;\n}\n \nlet writablePerson: Person = {\n  name: \"Person Mike\",\n  age: 42,\n};\n \n// works\nlet readonlyPerson: ReadonlyPerson = writablePerson;\n \nconsole.log(readonlyPerson.age); // prints '42'\nwritablePerson.age++;\n```\n\n## Conditional Types\n### Distributive Conditional Types\n``` typescript\n/*\n * Distributivity\n */\ntype ToArray<Type> = Type extends any ? Type[] : never;\ntype StrArrOrNumArr = ToArray<string | number>;\n// type StrArrOrNumArr = string[] | number[]\n\n\n/*\n * Avoid Distributivity\n */\ntype ToArrayNonDis<Type> = [Type] extends [any] ? Type[] : never;\ntype StrArrOrNumArr = ToArrayNonDis<string | number>;\n// type StrArrOrNumArr = (string | number)[]\n```\n\n## Mapping Types\nMapping Typesæ˜¯æŒ‡ä»ä¸€ç§ç±»å‹æ˜ å°„åˆ°å¦ä¸€ç§ç±»å‹\n### Mapping Modifier\nModifieræœ‰readonlyå’Œå¯é€‰ç¬¦å·ï¼Ÿï¼Œmodifieråœ¨æ˜ å°„è¿‡ç¨‹ä¸­æ”¹å˜ç±»å‹å±æ€§çš„ç‰¹æ€§, +/-è¡¨ç¤ºæ–°å¢/å»é™¤è¯¥ç‰¹æ€§\n- readonly\n```typescript\n// Removes 'readonly' attributes from a type's properties\ntype CreateMutable<Type> = {\n  -readonly [Property in keyof Type]: Type[Property];\n};\n \ntype LockedAccount = {\n  readonly id: string;\n  readonly name: string;\n};\n \ntype UnlockedAccount = CreateMutable<LockedAccount>;\n/*\n *type UnlockedAccount = {\n *  id: string;\n *  name: string;\n *}\n */\n```\n\n- å¯é€‰ç¬¦å·ï¼Ÿ\n``` typescript\n// Add 'optional' attributes from a type's properties\ntype Concrete<Type> = {\n  [Property in keyof Type]+?: Type[Property];\n};\n \ntype MaybeUser = {\n  id: string;\n  name: string;\n  age: number;\n};\n \ntype User = Concrete<MaybeUser>;\n/*\n *type User = {\n *  id?: string;\n *  name?: string;\n *  age?: number;\n *}\n */\n```\n\n## Class\n### implements Clauses\nimplements Clausesåªæ˜¯æ£€æŸ¥ç±»æ˜¯å¦å¯ä»¥è¢«è§†ä¸ºæ¥å£ç±»å‹ã€‚å®ƒæ ¹æœ¬ä¸ä¼šæ”¹å˜ç±»æˆ–å…¶æ–¹æ³•çš„ç±»å‹ã€‚\n```typescript\n// Example 1\ninterface Checkable {\n  check(name: string): boolean;\n}\n \nclass NameChecker implements Checkable {\n  check(s) {\n    // Parameter 's' implicitly has an 'any' type, è€Œä¸ä¼šå› ä¸ºimplementsäº†Checkableï¼Œè¢«æ¨æ–­ä¸ºstring\n    return s.toLowercse() === \"ok\";\n  }\n}\n\n// Example 2\ninterface A {\n  x: number;\n  y?: number;\n}\nclass C implements A {\n  x = 0;\n}\nconst c = new C();\nc.y = 10;\nProperty 'y' does not exist on type 'C'.\n```\n\nToRead:  handbook done!!!",
    "code": "var Component=(()=>{var d=Object.create;var a=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var h=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var g=(r,n)=>()=>(n||r((n={exports:{}}).exports,n),n.exports),b=(r,n)=>{for(var t in n)a(r,t,{get:n[t],enumerable:!0})},l=(r,n,t,o)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let i of h(n))!m.call(r,i)&&i!==t&&a(r,i,{get:()=>n[i],enumerable:!(o=y(n,i))||o.enumerable});return r};var T=(r,n,t)=>(t=r!=null?d(u(r)):{},l(n||!r||!r.__esModule?a(t,\"default\",{value:r,enumerable:!0}):t,r)),f=r=>l(a({},\"__esModule\",{value:!0}),r);var c=g((P,s)=>{s.exports=_jsx_runtime});var C={};b(C,{default:()=>A,frontmatter:()=>k});var e=T(c()),k={title:\"TypesScript Handbook Mark\",date:new Date(16675578e5)};function p(r){let n=Object.assign({h1:\"h1\",blockquote:\"blockquote\",p:\"p\",h2:\"h2\",h3:\"h3\",a:\"a\",ul:\"ul\",li:\"li\",pre:\"pre\",code:\"code\",br:\"br\"},r.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(n.h1,{id:\"typesscript-handbook\",children:\"TypesScript Handbook\"}),`\n`,(0,e.jsxs)(n.blockquote,{children:[`\n`,(0,e.jsx)(n.p,{children:\"Much of the time, you will know better than TypeScript.\"}),`\n`]}),`\n`,(0,e.jsx)(n.h2,{id:\"\\u5E38\\u89C1\\u7C7B\\u578B\",children:\"\\u5E38\\u89C1\\u7C7B\\u578B\"}),`\n`,(0,e.jsxs)(n.h3,{id:\"\\u7C7B\\u578B\\u522B\\u540D\\u548C\\u63A5\\u53E3\\u7684\\u533A\\u522B\",children:[\"\\u7C7B\\u578B\\u522B\\u540D\\u548C\\u63A5\\u53E3\\u7684\\u533A\\u522B\",(0,e.jsx)(n.a,{href:\"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces\",children:\"\\u{1F517}\"})]}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"\\u6269\\u5C55\"}),`\n`]}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-typescript\",children:`// interface\ninterfaces A extends B{\n  property1: string;\n  property2: string;\n}\n\n// type alias\ntype A  = {\n  property1: string;\n}\ntype B = {\n  property2: string;\n}\ntype Union = A & B\n`})}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"\\u91CD\\u590D\\u5B9A\\u4E49\\uFF1Ainterface\\u91CD\\u590D\\u5B9A\\u4E49\\u662F\\u5F80\\u63A5\\u53E3\\u5185\\u6DFB\\u52A0\\u5C5E\\u6027\\uFF0Ctype\\u7C7B\\u578B\\u522B\\u540D\\u4E0D\\u80FD\\u91CD\\u590D\\u5B9A\\u4E49\"}),`\n`]}),`\n`,(0,e.jsx)(n.h2,{id:\"narrowing\",children:\"Narrowing\"}),`\n`,(0,e.jsxs)(n.h3,{id:\"truthiness-narrowing\",children:[\"Truthiness narrowing\",(0,e.jsx)(n.a,{href:\"https://www.typescriptlang.org/docs/handbook/2/narrowing.html#truthiness-narrowing\",children:\"\\u{1F517}\"})]}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[\"Double-Boolean negation\\uFF1ATypeScript infers a narrow literal boolean type true\\uFF0Crather than boolean.\",(0,e.jsx)(n.br,{}),`\n`,(0,e.jsx)(n.code,{children:'!!\"str\"; //type: true value: true'}),(0,e.jsx)(n.br,{}),`\n`,(0,e.jsx)(n.code,{children:'Boolean(\"str); //type: boolean value: true'})]}),`\n`]}),`\n`,(0,e.jsx)(n.h2,{id:\"function-types\",children:\"Function Types\"}),`\n`,(0,e.jsx)(n.h2,{id:\"object-types\",children:\"Object Types\"}),`\n`,(0,e.jsx)(n.h3,{id:\"\\u53EA\\u8BFB\\u5C5E\\u6027\",children:\"\\u53EA\\u8BFB\\u5C5E\\u6027\\uFF1A\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"TS\\u5728\\u5224\\u65AD\\u662F\\u5426\\u662F\\u540C\\u4E00\\u7C7B\\u578B\\u65F6\\u4E0D\\u8003\\u8651readonly\\u5C5E\\u6027\"}),`\n`,(0,e.jsx)(n.li,{children:\"\\u53EF\\u901A\\u8FC7\\u4F7F\\u7528\\u522B\\u540D\\u6539\\u53D8readonly\\u5C5E\\u6027\"}),`\n`,(0,e.jsx)(n.li,{children:\"\\u666E\\u901A\\u7C7B\\u578B\\u503C\\u53EF\\u4EE5\\u8D4B\\u503C\\u7ED9readonly\\u53D8\\u91CF\\uFF0C\\u4F46readonly\\u503C\\u4E0D\\u80FD\\u590D\\u5236\\u7ED9\\u666E\\u901A\\u7C7B\\u578B\\u53D8\\u91CF\"}),`\n`]}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-typescript\",children:`interface Person {\n  name: string;\n  age: number;\n}\n \ninterface ReadonlyPerson {\n  readonly name: string;\n  readonly age: number;\n}\n \nlet writablePerson: Person = {\n  name: \"Person Mike\",\n  age: 42,\n};\n \n// works\nlet readonlyPerson: ReadonlyPerson = writablePerson;\n \nconsole.log(readonlyPerson.age); // prints '42'\nwritablePerson.age++;\n`})}),`\n`,(0,e.jsx)(n.h2,{id:\"conditional-types\",children:\"Conditional Types\"}),`\n`,(0,e.jsx)(n.h3,{id:\"distributive-conditional-types\",children:\"Distributive Conditional Types\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-typescript\",children:`/*\n * Distributivity\n */\ntype ToArray<Type> = Type extends any ? Type[] : never;\ntype StrArrOrNumArr = ToArray<string | number>;\n// type StrArrOrNumArr = string[] | number[]\n\n\n/*\n * Avoid Distributivity\n */\ntype ToArrayNonDis<Type> = [Type] extends [any] ? Type[] : never;\ntype StrArrOrNumArr = ToArrayNonDis<string | number>;\n// type StrArrOrNumArr = (string | number)[]\n`})}),`\n`,(0,e.jsx)(n.h2,{id:\"mapping-types\",children:\"Mapping Types\"}),`\n`,(0,e.jsx)(n.p,{children:\"Mapping Types\\u662F\\u6307\\u4ECE\\u4E00\\u79CD\\u7C7B\\u578B\\u6620\\u5C04\\u5230\\u53E6\\u4E00\\u79CD\\u7C7B\\u578B\"}),`\n`,(0,e.jsx)(n.h3,{id:\"mapping-modifier\",children:\"Mapping Modifier\"}),`\n`,(0,e.jsx)(n.p,{children:\"Modifier\\u6709readonly\\u548C\\u53EF\\u9009\\u7B26\\u53F7\\uFF1F\\uFF0Cmodifier\\u5728\\u6620\\u5C04\\u8FC7\\u7A0B\\u4E2D\\u6539\\u53D8\\u7C7B\\u578B\\u5C5E\\u6027\\u7684\\u7279\\u6027, +/-\\u8868\\u793A\\u65B0\\u589E/\\u53BB\\u9664\\u8BE5\\u7279\\u6027\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"readonly\"}),`\n`]}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-typescript\",children:`// Removes 'readonly' attributes from a type's properties\ntype CreateMutable<Type> = {\n  -readonly [Property in keyof Type]: Type[Property];\n};\n \ntype LockedAccount = {\n  readonly id: string;\n  readonly name: string;\n};\n \ntype UnlockedAccount = CreateMutable<LockedAccount>;\n/*\n *type UnlockedAccount = {\n *  id: string;\n *  name: string;\n *}\n */\n`})}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"\\u53EF\\u9009\\u7B26\\u53F7\\uFF1F\"}),`\n`]}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-typescript\",children:`// Add 'optional' attributes from a type's properties\ntype Concrete<Type> = {\n  [Property in keyof Type]+?: Type[Property];\n};\n \ntype MaybeUser = {\n  id: string;\n  name: string;\n  age: number;\n};\n \ntype User = Concrete<MaybeUser>;\n/*\n *type User = {\n *  id?: string;\n *  name?: string;\n *  age?: number;\n *}\n */\n`})}),`\n`,(0,e.jsx)(n.h2,{id:\"class\",children:\"Class\"}),`\n`,(0,e.jsx)(n.h3,{id:\"implements-clauses\",children:\"implements Clauses\"}),`\n`,(0,e.jsx)(n.p,{children:\"implements Clauses\\u53EA\\u662F\\u68C0\\u67E5\\u7C7B\\u662F\\u5426\\u53EF\\u4EE5\\u88AB\\u89C6\\u4E3A\\u63A5\\u53E3\\u7C7B\\u578B\\u3002\\u5B83\\u6839\\u672C\\u4E0D\\u4F1A\\u6539\\u53D8\\u7C7B\\u6216\\u5176\\u65B9\\u6CD5\\u7684\\u7C7B\\u578B\\u3002\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-typescript\",children:`// Example 1\ninterface Checkable {\n  check(name: string): boolean;\n}\n \nclass NameChecker implements Checkable {\n  check(s) {\n    // Parameter 's' implicitly has an 'any' type, \\u800C\\u4E0D\\u4F1A\\u56E0\\u4E3Aimplements\\u4E86Checkable\\uFF0C\\u88AB\\u63A8\\u65AD\\u4E3Astring\n    return s.toLowercse() === \"ok\";\n  }\n}\n\n// Example 2\ninterface A {\n  x: number;\n  y?: number;\n}\nclass C implements A {\n  x = 0;\n}\nconst c = new C();\nc.y = 10;\nProperty 'y' does not exist on type 'C'.\n`})}),`\n`,(0,e.jsx)(n.p,{children:\"ToRead:  handbook done!!!\"})]})}function w(r={}){let{wrapper:n}=r.components||{};return n?(0,e.jsx)(n,Object.assign({},r,{children:(0,e.jsx)(p,r)})):p(r)}var A=w;return f(C);})();\n;return Component;"
  },
  "_id": "3-TypeScript/index.mdx",
  "_raw": {
    "sourceFilePath": "3-TypeScript/index.mdx",
    "sourceFileName": "index.mdx",
    "sourceFileDir": "3-TypeScript",
    "contentType": "mdx",
    "flattenedPath": "3-TypeScript"
  },
  "type": "Framework",
  "url": "src/framework/3-TypeScript"
}