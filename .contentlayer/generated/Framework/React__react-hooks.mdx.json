{
  "title": "React Hooks",
  "date": "2022-09-30T02:30:00.000Z",
  "body": {
    "raw": " \n\n### Q：函数组件中的useState和类组件中setState的区别？(React Hooks)\n  - useState不同的state更新会触发多次渲染，类组件中setState会对state合并处理\n  - useState设置state值不变时不会触发渲染，类组件中setState会触发渲染\n\n### Q：useState和useReducer的区别?(React Hooks)\n  - 初始值\n    - const [state, setState] = useState(fn1(arg) | (s) => fn2(s)),若初始值是函数返回值，组件每次渲染都会执行fn1, 但不会赋值给state\n    而初始值是回调函数仅在组件初始化执行\n    - useReducer初始值, 第二参数只能是值或者函数返回值，且每次渲染会重复执行，但不会赋值给state，第三个参数可为回调函数，效果同上\n    - 注：以回调函数的方式初始化称为惰性初始化\n\n  - 修改状态\n    - useState同时setState多次，会被覆盖，只有最后一次会生效，组件渲染一次\n    - userReducer的dispatch同时多次调用，会顺序依次执行，组件渲染一次\n\n\n\n\n### Q：useEffect的依赖比较原理?(React Hooks)\n  - Object.is(arg1, arg2)，如果依赖为引用类型， 则比较的是两者的地址，而非值，会再次调用执行函数，如果在useEffect中修改了引用类型，则会引发无限渲染的问题\n\n### Q：useEffect中取到的state一直是旧值？(React Hooks)\n  - 组件的每一帧都有自己的state， props，下面这个组件只在初始化时添加了Click监听，此时count值为0，之后每次Click触发都是打印挂载监听时的count值\n  ``` jsx\n    function Counter() {\n        const [count, setCount] = useState(0);\n\n        useEffect(() => {\n          const handleClick = function() {\n            console.log('count: ', count);\n          }\n            window.addEventListener('click', handleClick, false)\n\n            return () => {\n              window.removeEventListener('click', handleClick, false)\n            };\n        }, []);\n\n        return <p onClick={() => setCount(count + 1)}>clicked {count} times</p>;\n    }\n  ```",
    "html": "<h3>Q：函数组件中的useState和类组件中setState的区别？(React Hooks)</h3>\n<ul>\n<li>useState不同的state更新会触发多次渲染，类组件中setState会对state合并处理</li>\n<li>useState设置state值不变时不会触发渲染，类组件中setState会触发渲染</li>\n</ul>\n<h3>Q：useState和useReducer的区别?(React Hooks)</h3>\n<ul>\n<li>\n<p>初始值</p>\n<ul>\n<li>const [state, setState] = useState(fn1(arg) | (s) => fn2(s)),若初始值是函数返回值，组件每次渲染都会执行fn1, 但不会赋值给state\n而初始值是回调函数仅在组件初始化执行</li>\n<li>useReducer初始值, 第二参数只能是值或者函数返回值，且每次渲染会重复执行，但不会赋值给state，第三个参数可为回调函数，效果同上</li>\n<li>注：以回调函数的方式初始化称为惰性初始化</li>\n</ul>\n</li>\n<li>\n<p>修改状态</p>\n<ul>\n<li>useState同时setState多次，会被覆盖，只有最后一次会生效，组件渲染一次</li>\n<li>userReducer的dispatch同时多次调用，会顺序依次执行，组件渲染一次</li>\n</ul>\n</li>\n</ul>\n<h3>Q：useEffect的依赖比较原理?(React Hooks)</h3>\n<ul>\n<li>Object.is(arg1, arg2)，如果依赖为引用类型， 则比较的是两者的地址，而非值，会再次调用执行函数，如果在useEffect中修改了引用类型，则会引发无限渲染的问题</li>\n</ul>\n<h3>Q：useEffect中取到的state一直是旧值？(React Hooks)</h3>\n<ul>\n<li>组件的每一帧都有自己的state， props，下面这个组件只在初始化时添加了Click监听，此时count值为0，之后每次Click触发都是打印挂载监听时的count值</li>\n</ul>\n<pre><code class=\"language-jsx\">  function Counter() {\n      const [count, setCount] = useState(0);\n\n      useEffect(() => {\n        const handleClick = function() {\n          console.log('count: ', count);\n        }\n          window.addEventListener('click', handleClick, false)\n\n          return () => {\n            window.removeEventListener('click', handleClick, false)\n          };\n      }, []);\n\n      return &#x3C;p onClick={() => setCount(count + 1)}>clicked {count} times&#x3C;/p>;\n  }\n</code></pre>"
  },
  "_id": "React/react-hooks.mdx",
  "_raw": {
    "sourceFilePath": "React/react-hooks.mdx",
    "sourceFileName": "react-hooks.mdx",
    "sourceFileDir": "React",
    "contentType": "mdx",
    "flattenedPath": "React/react-hooks"
  },
  "type": "Framework",
  "url": "src/framework/React/react-hooks"
}