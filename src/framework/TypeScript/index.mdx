---
title: TypesScript Handbook Mark
date: 2022-11-04 10:30:00
---

# TypesScript Handbook
> Much of the time, you will know better than TypeScript.

## 常见类型
### 类型别名和接口的区别 [🔗](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces)
- 扩展
```typescript
// interface
interfaces A extends B{
  property1: string;
  property2: string;
}

// type alias
type A  = {
  property1: string;
}
type B = {
  property2: string;
}
type Union = A & B
```
- 重复定义：interface重复定义是往接口内添加属性，type类型别名不能重复定义

## Narrowing
### Truthiness narrowing [🔗](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#truthiness-narrowing)
- Double-Boolean negation：TypeScript infers a narrow literal boolean type true，rather than boolean.  
`!!"str"; //type: true value: true`  
`Boolean("str); //type: boolean value: true`

## Function Types

## Object Types
### 只读属性：
- TS在判断是否是同一类型时不考虑readonly属性
- 可通过使用别名改变readonly属性
```typescript
interface Person {
  name: string;
  age: number;
}
 
interface ReadonlyPerson {
  readonly name: string;
  readonly age: number;
}
 
let writablePerson: Person = {
  name: "Person Mike",
  age: 42,
};
 
// works
let readonlyPerson: ReadonlyPerson = writablePerson;
 
console.log(readonlyPerson.age); // prints '42'
writablePerson.age++;
```

<CustomSandpack 
  template="react-ts" 
  files={{
    '/App.tsx': `interface Person {
        name: string;
        age: number;
      }
      
      interface ReadonlyPerson {
        readonly name: string;
        readonly age: number;
      }
      
      let writablePerson: Person = {
        name: "Person Mike",
        age: 42,
      };
      
      // works
      let readonlyPerson: ReadonlyPerson = writablePerson;
      
      console.log(readonlyPerson.age); // prints '42'
      writablePerson.age++;
    `,
  }} 
/>