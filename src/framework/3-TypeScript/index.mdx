---
title: TypesScript Handbook Mark
date: 2022-11-04 10:30:00
---

# TypesScript Handbook
> Much of the time, you will know better than TypeScript.

## å¸¸è§ç±»å‹
### ç±»å‹åˆ«åå’Œæ¥å£çš„åŒºåˆ« [ğŸ”—](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces)
- æ‰©å±•
```typescript
// interface
interfaces A extends B{
  property1: string;
  property2: string;
}

// type alias
type A  = {
  property1: string;
}
type B = {
  property2: string;
}
type Union = A & B
```
- é‡å¤å®šä¹‰ï¼šinterfaceé‡å¤å®šä¹‰æ˜¯å¾€æ¥å£å†…æ·»åŠ å±æ€§ï¼Œtypeç±»å‹åˆ«åä¸èƒ½é‡å¤å®šä¹‰

## Narrowing
### Truthiness narrowing [ğŸ”—](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#truthiness-narrowing)
- Double-Boolean negationï¼šTypeScript infers a narrow literal boolean type trueï¼Œrather than boolean.  
`!!"str"; //type: true value: true`  
`Boolean("str); //type: boolean value: true`

## Function Types

## Object Types
### åªè¯»å±æ€§ï¼š
- TSåœ¨åˆ¤æ–­æ˜¯å¦æ˜¯åŒä¸€ç±»å‹æ—¶ä¸è€ƒè™‘readonlyå±æ€§
- å¯é€šè¿‡ä½¿ç”¨åˆ«åæ”¹å˜readonlyå±æ€§
- æ™®é€šç±»å‹å€¼å¯ä»¥èµ‹å€¼ç»™readonlyå˜é‡ï¼Œä½†readonlyå€¼ä¸èƒ½å¤åˆ¶ç»™æ™®é€šç±»å‹å˜é‡
```typescript
interface Person {
  name: string;
  age: number;
}
 
interface ReadonlyPerson {
  readonly name: string;
  readonly age: number;
}
 
let writablePerson: Person = {
  name: "Person Mike",
  age: 42,
};
 
// works
let readonlyPerson: ReadonlyPerson = writablePerson;
 
console.log(readonlyPerson.age); // prints '42'
writablePerson.age++;
```

## Conditional Types
### Distributive Conditional Types
``` typescript
/*
 * Distributivity
 */
type ToArray<Type> = Type extends any ? Type[] : never;
type StrArrOrNumArr = ToArray<string | number>;
// type StrArrOrNumArr = string[] | number[]


/*
 * Avoid Distributivity
 */
type ToArrayNonDis<Type> = [Type] extends [any] ? Type[] : never;
type StrArrOrNumArr = ToArrayNonDis<string | number>;
// type StrArrOrNumArr = (string | number)[]
```

## Mapping Types
Mapping Typesæ˜¯æŒ‡ä»ä¸€ç§ç±»å‹æ˜ å°„åˆ°å¦ä¸€ç§ç±»å‹
### Mapping Modifier
Modifieræœ‰readonlyå’Œå¯é€‰ç¬¦å·ï¼Ÿï¼Œmodifieråœ¨æ˜ å°„è¿‡ç¨‹ä¸­æ”¹å˜ç±»å‹å±æ€§çš„ç‰¹æ€§, +/-è¡¨ç¤ºæ–°å¢/å»é™¤è¯¥ç‰¹æ€§
- readonly
```typescript
// Removes 'readonly' attributes from a type's properties
type CreateMutable<Type> = {
  -readonly [Property in keyof Type]: Type[Property];
};
 
type LockedAccount = {
  readonly id: string;
  readonly name: string;
};
 
type UnlockedAccount = CreateMutable<LockedAccount>;
/*
 *type UnlockedAccount = {
 *  id: string;
 *  name: string;
 *}
 */
```

- å¯é€‰ç¬¦å·ï¼Ÿ
``` typescript
// Add 'optional' attributes from a type's properties
type Concrete<Type> = {
  [Property in keyof Type]+?: Type[Property];
};
 
type MaybeUser = {
  id: string;
  name: string;
  age: number;
};
 
type User = Concrete<MaybeUser>;
/*
 *type User = {
 *  id?: string;
 *  name?: string;
 *  age?: number;
 *}
 */
```

## Class
### implements Clauses
implements Clausesåªæ˜¯æ£€æŸ¥ç±»æ˜¯å¦å¯ä»¥è¢«è§†ä¸ºæ¥å£ç±»å‹ã€‚å®ƒæ ¹æœ¬ä¸ä¼šæ”¹å˜ç±»æˆ–å…¶æ–¹æ³•çš„ç±»å‹ã€‚
```typescript
// Example 1
interface Checkable {
  check(name: string): boolean;
}
 
class NameChecker implements Checkable {
  check(s) {
    // Parameter 's' implicitly has an 'any' type, è€Œä¸ä¼šå› ä¸ºimplementsäº†Checkableï¼Œè¢«æ¨æ–­ä¸ºstring
    return s.toLowercse() === "ok";
  }
}

// Example 2
interface A {
  x: number;
  y?: number;
}
class C implements A {
  x = 0;
}
const c = new C();
c.y = 10;
Property 'y' does not exist on type 'C'.
```

ToRead:  handbook done!!!